(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{487:function(a,t,e){"use strict";e.r(t);var s=e(1),n=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"day1-两数之和"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day1-两数之和"}},[a._v("#")]),a._v(" day1 两数之和")]),a._v(" "),t("blockquote",[t("p",[a._v("解法：")]),a._v(" "),t("p",[a._v("枚举每一个元素，找出target-x的对应元素，并返回数组")])]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int index = size(nums);\n        for (int i = 0; i < index; i++) {\n            for (int j = i + 1; j < index; j++) {\n                if (nums[i] + nums[j] == target)\n                    return { i,j };\n            }\n        }\n        return {};\n    }\n};\n")])])]),t("blockquote",[t("p",[a._v("hashtable的解法：")]),a._v(" "),t("p",[a._v("创建一个hash表，取每一个x值的时候，都向hash表中查找是否存在target-x的元素。存在返回这两元素的下标，不存在就插入。")])]),a._v(" "),t("h3",{attrs:{id:"hashtable的写法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashtable的写法"}},[a._v("#")]),a._v(" hashtable的写法")]),a._v(" "),t("p",[t("img",{attrs:{src:"https://wangdengdeng.oss-cn-hangzhou.aliyuncs.com/NewPic/202303280915338.png",alt:"image-20230328091525244"}})]),a._v(" "),t("h4",{attrs:{id:"初始化定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#初始化定义"}},[a._v("#")]),a._v(" 初始化定义")]),a._v(" "),t("p",[a._v("**#include <unordered_map>**头文件声明")]),a._v(" "),t("p",[t("strong",[a._v("unordered_map<int, int> hashtable;")]),a._v("（声明key和value的类型）")]),a._v(" "),t("h4",{attrs:{id:"遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[a._v("#")]),a._v(" 遍历")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('for (auto iter = umap.begin(); iter != umap.end(); ++iter) {\n        cout << "<" << iter->first << ", " << iter->second << ">" << endl;\n    }\n')])])]),t("h4",{attrs:{id:"查找"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查找"}},[a._v("#")]),a._v(" 查找")]),a._v(" "),t("p",[t("code",[a._v("it = hashtable.find(nums[i])")])]),a._v(" "),t("p",[a._v("注意find内的是key，后续hashtable中存的时候是值对应的索引")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("it->first  索引key\nit->second 对应value\n    \n")])])]),t("h5",{attrs:{id:"find与count的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#find与count的区别"}},[a._v("#")]),a._v(" find与count的区别")]),a._v(" "),t("p",[t("code",[a._v("hashtable.count(nums[i])")])]),a._v(" "),t("p",[a._v("count用于查找key对应value的个数，==哈希表中存不存在键为（num[i]）的键值对，可直接返回（有就是1，没有就是0）== 而find不能直接返回。")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('auto p = hashmap.find(1);\n    if(p != hashmap.end()) puts("找到了")\n')])])]),t("h4",{attrs:{id:"判空"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判空"}},[a._v("#")]),a._v(" 判空")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//如果容器大小为0则返回true，否则返回false\nmymap.empty()\n")])])]),t("h4",{attrs:{id:"容量判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容量判断"}},[a._v("#")]),a._v(" 容量判断")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//返回unordered_map容器中的存在的元素数量。\nmymap.size()\n")])])]),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//返回unordered_map容器可以容纳的元素的最大数量。\nmymap.max_size()\n")])])]),t("h2",{attrs:{id:"day2-回文数判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day2-回文数判断"}},[a._v("#")]),a._v(" day2 回文数判断")]),a._v(" "),t("h3",{attrs:{id:"一、不使用类型转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、不使用类型转换"}},[a._v("#")]),a._v(" 一、不使用类型转换")]),a._v(" "),t("blockquote",[t("p",[a._v("解法:")]),a._v(" "),t("p",[a._v("需要知道如何获取整数的末位以及从后向前获取每一位。")])]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("int x; //非负整数\nint rever =0; //逆序数\n\nwhile(x!=0){    \t\t\t//x%10能够获取末位,x/10之后会将去掉末位的数构成一个新的数。之后进行循环。\nrever = rever*10 + x/10;\nx = x/10;\n}\n")])])]),t("p",[a._v("==注意==")]),a._v(" "),t("p",[a._v("int 最大2的23次-1，所以反转之后的数字应设为long int类型，以防越界。")]),a._v(" "),t("p",[a._v("最后，将rever与x作判断，相同则为回文串。")]),a._v(" "),t("p",[a._v("int 除法是向下取整，就是直接取整数部分。")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("a/b; //向下取整\n(a-1) / b+1;//实现向上取整\n")])])]),t("h3",{attrs:{id:"二、使用类型转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、使用类型转换"}},[a._v("#")]),a._v(" 二、使用类型转换")]),a._v(" "),t("h4",{attrs:{id:"_1-使用compare函数以及reverse函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用compare函数以及reverse函数"}},[a._v("#")]),a._v(" 1.使用compare函数以及reverse函数")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\t\tstring S = to_string(x);\n        string SS = S;\n        reverse(S.begin(), S.end());\n        int flag = SS.compare(S);\n")])])]),t("p",[a._v("compare适用于string类型，而strcmp是char的比较函数，不能混用。")]),a._v(" "),t("p",[a._v("若 = 返回 0\n若 > 返回 1\n若 < 返回 -1")]),a._v(" "),t("h4",{attrs:{id:"_2-不使用函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-不使用函数"}},[a._v("#")]),a._v(" 2.不使用函数")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("for (int i = 0; i < length /2; i++)\n        {\n            swap(S[i], S[length - 1 - i]);\n        }\n")])])]),t("p",[a._v("可直接比较")]),a._v(" "),t("p",[t("code",[a._v("if(S==SS) return true;")])]),a._v(" "),t("h2",{attrs:{id:"day3-罗马数字转换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day3-罗马数字转换"}},[a._v("#")]),a._v(" day3 罗马数字转换")]),a._v(" "),t("blockquote",[t("p",[a._v("解法：")]),a._v(" "),t("p",[a._v("将每个字符向右比较，如果小于就取负，然后全部相加")])]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("#include <iostream>\n#include <string>\n#include <unordered_map>\nusing namespace std;\n    int getint(char ss) {\n        switch (ss)\n        {\n        case 'I': return 1; break;\n        case 'V': return 5; break;\n        case 'X': return 10; break;\n        case 'L': return 50; break;\n        case 'C': return 100; break;\n        case 'D': return 500; break;\n        case 'M': return 1000; break;\n        default: return 0; break;\n        }\n    }\n    int main() {\n        string s = \"MCMXCIV\";\n        int sum = 0;\n        int n1 = getint(s[0]);\n        for (int i = 1; i < s.size(); i++)\n        {\n            int n2=getint(s[i]);\n            if (n2<=n1)\n            {\n                sum+=n1;\n            }\n            else\n            {\n                sum-= n1;\n            }\n            n1 = n2;\n        }\n        sum = sum + n1;\n        cout << sum << endl;\n    }\n")])])]),t("h2",{attrs:{id:"day4-最长公共前缀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day4-最长公共前缀"}},[a._v("#")]),a._v(" day4 最长公共前缀")]),a._v(" "),t("blockquote",[t("p",[a._v("解法：")]),a._v(" "),t("p",[a._v("将容器中的第一个字符串取出做初始公共前缀，然后向后比较（==写函数==），得出最大公共前缀")])]),a._v(" "),t("p",[a._v("没搞清的点就是"),t("strong",[a._v("起始俩串的最大公共前缀可以直接拿来和之后的进行对比，实现一个递归的效果")])]),a._v(" "),t("p",[a._v("以及"),t("strong",[a._v("省时间的办法就是前缀的判断只需要取较短的串长度作为循环次数")])]),a._v(" "),t("p",[a._v("容器vector的参数传递尽量使用引用传递"),t("code",[a._v("vector string& s")])]),a._v(" "),t("p",[a._v("string 的传递也是 "),t("code",[a._v("string&")])]),a._v(" "),t("h2",{attrs:{id:"day5-括号匹配"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#day5-括号匹配"}},[a._v("#")]),a._v(" day5 括号匹配")]),a._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("class Solution {\npublic:\n    bool isValid(string s) { // 题给\n        int n = s.size();\t\n        if (n % 2 == 1) {\t//如果串的个数为奇数，直接返回false\n            return false;\n        }\n        unordered_map<char, char> pairs = {  // 用哈希表做判断\n            {')', '('},\n            {']', '['},\n            {'}', '{'}\n        };\n        stack<char> stk; // 栈初始化\n        for (char ch : s) {\t//字符串遍历\n            if (pairs.count(ch)) {\t// 若哈希表中含有字符\n                if (stk.empty() || stk.top() != pairs[ch]) { // 栈空 || 栈顶不能和哈希表的值对应\n                    return false;\n                }\n                stk.pop();  // 匹配就出栈\n            }\n            else {\n                stk.push(ch); // 哈希表中没有，就入栈\n            }\n        }\n        return stk.empty(); \n    }\n};\n")])])]),t("p",[a._v("3011716019----19275434620----1369----1243----月亮船群接码")]),a._v(" "),t("p",[a._v("格式为：账号----密码 先上号验号， 可换绑的当天必须换手机 不换后期出现任何问题不包售后 没换绑之前不要充值 账号不包峡谷！近期腾讯bug原因个别号前期限制发言和单向加好友可以互加！用过有问题不退换!!! 虐菜或者被举报账号会被限制登录， 需要等几天自己解除才能游戏，最后请亲确认收货给个5星带字好评吧  /:803后期有问题可来找售后处理 （账号长期不登录，TX会收回）")]),a._v(" "),t("p",[a._v("3011716019----ccdd1107----艾欧尼亚----Hixmv----30----34795")])])}),[],!1,null,null,null);t.default=n.exports}}]);